import isArray from "lodash/fp/isArray";
import { generatePath, pathToRegex } from "./helpers";

/**
 * validPluginsRoutes returns if given every route from `routes` array has both
 * `path` and `fetch` attributes.
 * @param {Array} routes
 * @returns {Bool} isValid
 */
export function validPluginsRoutes(routes) {
  return (
    routes &&
    isArray(routes) &&
    routes.every((route) => route.path && route.fetch)
  );
}

/**
 * ProxyConfig is an object that maps the received route to target routes.
 * @typedef {Object} ProxyConfig
 */
/**
 * proxyHandler is responsible for handling route redirecting. It receives a
 * `config` object, and, for given `targetPath`, returns the corresponding route
 *  from `allRoutes` + proxy targets routes.
 * @param {ProxyConfig} config proxy config
 * @returns {ProxyHandler} Plugins Proxy handler
 */
function proxyHandler(config) {
  return {
    get: (allRoutes, targetPath) => {
      function findRoute(path) {
        return allRoutes.find((r) => r.path === path);
      }
      // Find proxy config key that matches the targetPath. Required to find
      // routes without formatting their params.
      const proxyConfigMatch = Object.keys(config).find((route) =>
        targetPath.match(pathToRegex(route))
      );
      // Get targets once we know the correct path.
      const targets = (config && config[proxyConfigMatch]) || [];
      // Routes that match the targetPath without proxy.
      const unhandledTarget = findRoute(targetPath);
      // Routes that match target proxy routes.
      const proxiedTargets = targets.map(findRoute);
      // Remove undefined values. In case some route or target does not match
      // current routes.
      return [unhandledTarget, ...proxiedTargets].filter((t) => !!t);
    },
  };
}

/**
 * configurePluginsRouter returns a configured router to run on app background.
 * This router won't render views, ans instead, it's used as a listener for
 * routes changes.
 */
function configurePluginsRouter() {
  let routes = null;
  let proxyConfig;

  async function verifyMatches(pathname) {
    const routesProxy = new Proxy(routes, proxyHandler(proxyConfig));
    // Get routes match from proxy
    const targetRoutes = routesProxy[pathname];
    for (const route of targetRoutes) {
      // Every plugin route has its own fetch method, and plugins router
      // listens to window location pathname and triggers the fetching.
      if (route.fetch) {
        await route.fetch();
      }
    }
  }

  return {
    /**
     * navigateTo receives an URL and executes the fetching for routes matches.
     * @param {string} url
     */
    async navigateTo(url) {
      if (!routes) {
        throw Error("router is not initialized. Use the init method");
      }
      // Accepts pathnames and urls. Handle Pathnames correctly
      let pathname;
      try {
        pathname = new URL(url).pathname;
      } catch (_) {
        pathname = url;
      }
      await verifyMatches(pathname);
    },
    /**
     * call executes the fetching for matches with an url generated by `path`
     * and `params`.
     * ```
     * // Example:
     * call("/some/:token", { token: "abcdefg" })
     * // will call the "/some/abcdefg" route.
     * ```
     * @param {string} path Route path
     * @param {Object} params Route params
     */
    async call(path, params) {
      const url = generatePath(path, params);
      await verifyMatches(url);
    },
    /**
     * setupProxyConfig applies a ProxyConfig
     * @param {ProxyConfig} config
     */
    setupProxyConfig(config) {
      proxyConfig = config;
    },
    cleanup() {
      routes = null;
      proxyConfig = undefined;
    },
    /**
     * init initializes the router for given routes config
     * @param {{ routes: Array }} Config
     */
    async init({ routes: pluginsRoutes } = {}) {
      if (!pluginsRoutes || !validPluginsRoutes(pluginsRoutes)) {
        throw TypeError("`routes` must be an array of { path, fetch } ");
      }
      routes = pluginsRoutes;
      await verifyMatches(window.location.pathname);
    },
  };
}

/**
 * pluginsRouter describes a router to run on some app-shell background. This
 * router is used for app plugins integration, where some plugin can trigger a
 * determined `fetch` action when it hits the expected route.
 *
 * Since this router does not render views, we can have multiple matches for
 * a single route path, which are executed according to plugins configuration
 * or `proxyConfig` order.
 */
export const pluginsRouter = configurePluginsRouter();
