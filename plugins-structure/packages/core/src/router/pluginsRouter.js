import zipObject from "lodash/zipObject";
import sortBy from "lodash/fp/sortBy";
import isArray from "lodash/fp/isArray";
import { findMatch, generatePath, getParams } from "./helpers";

/**
 * ProxyConfig is an object that maps the received route to target routes.
 * @typedef {Object} ProxyConfig
 */

/**
 * validRoutes returns if given every route from `routes` array has both `path`
 * and `fetch` attributes.
 * @param {Array} routes
 * @returns {Bool} isValid
 */
export function validPluginsRoutes(routes) {
  return (
    routes &&
    isArray(routes) &&
    routes.every((route) => route.path && route.fetch)
  );
}

/**
 * filterRoutesByMatchTargets returns a callback function that checks if given
 * route corresponds to a match target
 * @param {Object} match
 */
function filterRoutesByMatchTargets(match) {
  return (route) => match.route.targets.some((target) => target === route.path);
}

function sortByTargetsOrder(match, routes) {
  return sortBy((route) => match.route.targets.indexOf(route.route.path))(
    routes
  );
}

/**
 * routesWithMatchParams returns a callback function that enhances given route
 * with given match `params`, corresponding to route params keys.
 * @param {Object} match
 */
function routesWithMatchParams(match) {
  return (route) => {
    const paramsKeys = Array.from(route.path.matchAll(/:(\w+)/g)).map(
      (result) => result[1]
    );
    const paramsValues = match.result.slice(1);
    const params = zipObject(paramsKeys, paramsValues);
    return { route, params };
  };
}

/**
 * proxy is responsible for handling route redirecting. It receives a `config`,
 * and, for given `targetRoute`, returns the corresponding `routes` route and
 * proxy targets route.
 * @param {ProxyConfig} config proxy config
 * @param {Array} routes proxy default routes
 * @param {string} targetRoute route to match on proxy
 * @returns {Array} target proxy routes.
 */
function proxy(config = {}, routes = [], targetRoute) {
  let targetRoutes = [];
  // Format proxy routes to use it on findMatch
  const proxyRoutes = Object.keys(config).map((route) => ({
    path: route,
    targets: config[route],
  }));
  // 1. Search on proxy to see if it matches the proxy
  const proxyMatch = findMatch(proxyRoutes, targetRoute);
  // If proxy matches, get corresponding targets with match params.
  if (proxyMatch) {
    const unorderedRoutes = routes
      .filter(filterRoutesByMatchTargets(proxyMatch))
      .map(routesWithMatchParams(proxyMatch));

    targetRoutes = sortByTargetsOrder(proxyMatch, unorderedRoutes);
  }
  // 2. Get regular routes matches (without proxy).
  const regularMatch = findMatch(routes, targetRoute);
  if (regularMatch) {
    targetRoutes = [
      { route: regularMatch.route, params: getParams(regularMatch) },
      ...targetRoutes,
    ];
  }
  return targetRoutes;
}

/**
 * configurePluginsRouter returns a configured router to run on app background.
 * This router won't render views, ans instead, it's used as a listener for
 * routes changes.
 */
function configurePluginsRouter() {
  let routes = null;
  let proxyConfig;

  async function verifyMatches(pathname) {
    // Get routes match from proxy
    const targetRoutes = proxy(proxyConfig, routes, pathname);
    for (const match of targetRoutes) {
      // Every plugin route has its own fetch method, and plugins router
      // listens to window location pathname and triggers the fetching.
      if (match.route.fetch) {
        await match.route.fetch(match.params);
      }
    }
  }

  return {
    /**
     * navigateTo receives an URL and executes the fetching for routes matches.
     * @param {string} url
     */
    async navigateTo(url) {
      if (!routes) {
        throw Error("router is not initialized. Use the init method");
      }
      // Accepts pathnames and urls. Handle Pathnames correctly
      let pathname;
      try {
        pathname = new URL(url).pathname;
      } catch (_) {
        pathname = url;
      }
      await verifyMatches(pathname);
    },
    /**
     * call executes the fetching for matches with an url generated by `path`
     * and `params`.
     * ```
     * // Example:
     * call("/some/:token", { token: "abcdefg" })
     * // will call the "/some/abcdefg" route.
     * ```
     * @param {string} path Route path
     * @param {Object} params Route params
     */
    async call(path, params) {
      const url = generatePath(path, params);
      await verifyMatches(url);
    },
    /**
     * setupProxyConfig applies a ProxyConfig
     * @param {ProxyConfig} config
     */
    setupProxyConfig(config) {
      proxyConfig = config;
    },
    cleanup() {
      routes = null;
      proxyConfig = undefined;
    },
    /**
     * init initializes the router for given routes config
     * @param {{ routes: Array }} Config
     */
    async init({ routes: pluginsRoutes } = {}) {
      if (!pluginsRoutes || !validPluginsRoutes(pluginsRoutes)) {
        throw TypeError("`routes` must be an array of { path, fetch } ");
      }
      routes = pluginsRoutes;
      await verifyMatches(window.location.pathname);
    },
  };
}

/**
 * pluginsRouter describes a router to run on some app-shell background. This
 * router is used for app plugins integration, where some plugin can trigger a
 * determined `fetch` action when it hits the expected route.
 *
 * Since this router does not render views, we can have multiple matches for
 * a single route path, which are executed according to plugins configuration
 * or `proxyConfig` order.
 */
export const pluginsRouter = configurePluginsRouter();
