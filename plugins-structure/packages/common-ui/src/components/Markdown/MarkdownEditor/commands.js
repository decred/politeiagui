import React from "react";
import { ButtonIcon } from "pi-ui";
import { redoStateChange, saveStateChanges, undoStateChange } from "./utils";
import { createNextState } from "@reduxjs/toolkit";
import { getMultiLineContent, getSelectedContent } from "./utils";
/**
 * @typedef {Object} TextSelection
 * @property {String} previous text before selection
 * @property {String | String[]} current text inside selection.
 * @property {String} next text after selection
 */
/**
 * Selection describes the editor text selection properties.
 * @typedef {Object} Selection
 * @property {Number} start editor selection start
 * @property {Number} end editor selection end
 * @property {TextSelection} lines lines selected
 * @property {TextSelection} cursor selected cursor content
 */
/**
 * CurrentChange describes an editor change. It
 * @typedef {Object} CurrentChange
 * @property {Selection} selection editor text selection
 * @property {String} content target text
 */
/**
 * ChangesState is the interface that describes an editor change.
 * @typedef {Object} ChangesState
 * @property {String} content content inside selection,
 * @property {Number} selectionStart start of the cursor selection,
 * @property {Number} selectionEnd end of the cursor selection,
 */
/**
 * EditorState is the immutable data structure generated by commandsReducer.
 * @typedef {{
 *  currentState: ChangesState,
 *  previousStates: ChangesState[],
 *  nextStates: ChangesState[]
 * }} EditorState
 */
/**
 * Command is a callback executed when the editor triggers a command. It
 * receives an EditorState immutable data structure (ImmerJS) from the
 * commandsReducer.
 *
 * @callback Command
 * @param {EditorState} editorState editor changes state
 * @param {CurrentChange} currentChange current changes params to be applied
 * @returns {void}
 */
/**
 * MarkdownEditorCommand is an interface that describes a markdown editor valid
 * command. It includes a Command and other configuration parameters to execute
 * this command.
 * @typedef {Object} MarkdownEditorCommand
 * @property {String} label command label
 * @property {String} commandKey keyboard character to activate command
 * (optional)
 * @property {Boolean} shift command should trigger when pressing shift key
 * @property {React.Component} Button action button to trigger command
 * @property {Command} command Command to be executed when buttons or keys are
 * pressed.
 */

/**
 * formatEachLine applies the formatFn to all lines.
 */
function formatEachLine(lines, formatFn, { ignoreBlankLines } = {}) {
  let index = 0;
  return lines.reduce((acc, curr, i) => {
    if (ignoreBlankLines && curr.length === 0 && i) {
      return `${acc}\n`;
    }
    index++;
    return `${acc}${!!i ? "\n" : ""}${formatFn(curr, index)}`;
  }, "");
}

/**
 * initializeEditorReducer returns a valid EditorState for given initialValue
 * string.
 * @param {String} initialValue initial editor content
 * @returns {EditorState} initial editor state
 */
export function initializeEditorReducer(initialValue = "") {
  return {
    currentState: {
      content: initialValue,
      selectionStart: initialValue.length,
      selectionEnd: initialValue.length,
    },
    previousStates: [
      {
        content: initialValue,
        selectionStart: initialValue.length,
        selectionEnd: initialValue.length,
      },
    ],
    nextStates: [],
  };
}

/**
 * commandsReducer is the reducer to manage commands. It receives an action
 * dispatched with a Command (`command`) and a ChangesState (`currentChange`),
 * and returns a new EditorState.
 *
 * @param {EditorState} editorState
 * @param {{
 *  command: Command,
 *  currentChange: ChangesState
 * }}
 * @returns {EditorState} new editor state
 */
export function commandsReducer(editorState, { command, currentChange }) {
  if (!currentChange) {
    return createNextState(command)(editorState);
  }
  const { content, selectionStart, selectionEnd } = currentChange;
  const cursor = getSelectedContent(content, selectionStart, selectionEnd);
  const lines = getMultiLineContent(content, selectionStart, selectionEnd);
  const currentChangeToBeApplied = {
    selection: { lines, cursor, start: selectionStart, end: selectionEnd },
    content,
  };
  const { currentState, previousStates, nextStates } = createNextState(command)(
    editorState,
    currentChangeToBeApplied
  );
  return { currentState, previousStates, nextStates };
}

/**
 * createEditorCommand returns a custom Markdown Editor command object. By
 * default, all commands save the editor state before being executed, but it can
 * be prevented if `skipSaving` is true.
 * @param {{
 *  label: String,
 *  commandKey: String,
 *  command: Command,
 *  shift: Boolean,
 *  skipSaving: Boolean
 *  buttonType: String,
 *  buttonViewBox: String
 * }}
 * @returns {MarkdownEditorCommand} Markdown Editor Command
 */
export function createEditorCommand({
  label,
  commandKey,
  command,
  shift,
  skipSaving,
  buttonType,
  buttonViewBox,
} = {}) {
  return {
    label,
    commandKey,
    shift,
    Button: buttonType
      ? ({ onClick }) => (
          <ButtonIcon
            type={buttonType}
            onClick={onClick}
            viewBox={buttonViewBox}
          />
        )
      : null,
    command: (state, currentChange) => {
      !skipSaving && saveStateChanges(state);
      command(state, currentChange);
    },
  };
}

/**
 * multilineCommand is the interface for executing a command on every selected
 * line.
 * @param {Command} command A command to be executed on selected lines
 * @param {Object} config
 */
export const multiLineCommand =
  (command, { offset, ignoreBlankLines }) =>
  (state, currentChange) => {
    const { start, end, lines } = currentChange.selection;
    const { previous, current, next } = lines;
    const formattedLines = formatEachLine(current, command, {
      ignoreBlankLines,
    });
    let newPrev = `${previous}\n`;
    if (previous.length === 0) {
      newPrev = "";
    }
    state.currentState = {
      content: `${newPrev}${formattedLines}\n${next}`,
      selectionStart: start + offset,
      selectionEnd: end + offset,
    };
  };

/**
 * cursorSelectionCommand is the interface for executing a command the content
 * inside the selected positions.
 * @param {Command} command A command to be executed on selected lines
 * @param {Object} config
 */
export const cursorSelectionCommand =
  (command, { offset }) =>
  (state, currentChange) => {
    const {
      selection: { cursor, start, end },
    } = currentChange;
    const newContent = command(cursor);
    state.currentState.content = newContent;
    state.currentState.selectionStart = start + offset;
    state.currentState.selectionEnd = end + offset;
  };

/**
 * regularChangeCommand updates the current state with the content from
 * currentChange.
 * @param {EditorState} editorState Editor State
 * @param {CurrentChange} currentChange Change object
 */
export function regularChangeCommand(editorState, currentChange) {
  editorState.currentState.content = currentChange.content;
}

/**
 * commandsMap is the MarkdownEditorCommands map.
 */
export const commandsMap = {
  undo: createEditorCommand({
    label: "Undo",
    commandKey: "z",
    skipSaving: true,
    command: undoStateChange,
  }),
  redo: createEditorCommand({
    label: "Redo",
    commandKey: "z",
    shift: true,
    skipSaving: true,
    command: redoStateChange,
  }),
  bold: createEditorCommand({
    label: "Bold Text",
    commandKey: "b",
    buttonType: "bold",
    buttonViewBox: "0 0 16 16",
    command: cursorSelectionCommand(
      ({ previous, current, next }) => `${previous}**${current}**${next}`,
      { offset: 2 }
    ),
  }),
  italic: createEditorCommand({
    label: "Italic",
    commandKey: "i",
    buttonType: "italic",
    buttonViewBox: "0 0 16 16",
    command: cursorSelectionCommand(
      ({ previous, current, next }) => `${previous}_${current}_${next}`,
      { offset: 1 }
    ),
  }),
  quote: createEditorCommand({
    label: "Quote",
    buttonType: "quote",
    buttonViewBox: "0 0 16 16",
    command: multiLineCommand((curr) => `> ${curr}`, {
      offset: 2,
      ignoreBlankLines: true,
    }),
  }),
  code: createEditorCommand({
    label: "Code",
    buttonType: "code",
    buttonViewBox: "0 0 16 16",
    command: cursorSelectionCommand(
      ({ previous, current, next }) => `${previous}\`${current}\`${next}`,
      { offset: 1 }
    ),
  }),
  list: createEditorCommand({
    label: "List",
    buttonType: "bulletList",
    buttonViewBox: "0 0 16 16",
    command: multiLineCommand((curr) => `- ${curr}`, {
      offset: 2,
      ignoreBlankLines: true,
    }),
  }),
  numberedList: createEditorCommand({
    label: "Numbered List",
    buttonType: "numberedList",
    buttonViewBox: "0 0 16 16",
    command: multiLineCommand((curr, i) => `${i}. ${curr}`, {
      offset: 3,
      ignoreBlankLines: true,
    }),
  }),
  taskList: createEditorCommand({
    label: "Task List",
    buttonType: "taskList",
    buttonViewBox: "0 0 16 16",
    command: multiLineCommand((curr) => `- [ ] ${curr}`, {
      offset: 6,
      ignoreBlankLines: true,
    }),
  }),
};

/**
 * commands is the MarkdownEditorCommands list.
 * @type { MarkdownEditorCommand[] } Editor Commands list
 */
export const commands = Object.values(commandsMap);
